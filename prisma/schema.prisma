generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model LoginAdministrator {
  id               Int       @id @default(autoincrement())
  email            String    @unique
  password         String
  emailRecovery    String
  resetToken       String?
  resetTokenExpiry DateTime?

  Administrator Administrator? // 1-1: Um LoginAdministrator está associado a um administrador

  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt
}

model Administrator {
  id       Int     @id @default(autoincrement())
  isMaster Boolean @default(false)

  personId   Int @unique // 1-1 : Um administrador está associado a uma pessoa
  loginAdmId Int @unique // 1-1 : Um administrador está associado a um login

  person Person             @relation(fields: [personId], references: [id])
  login  LoginAdministrator @relation(fields: [loginAdmId], references: [id])
}

// NÃO ESQUECER DE COLOCAR O cpf PARA @UNIQUE E RETIRAR O @default("") QUANDO ELE FOR IMPLEMENTADO
model Person {
  id   Int      @id @default(autoincrement())
  name String
  cpf  String   @default("")
  born DateTime @default(now())

  user          User? // 1-1 : (Opcional) Uma pessoa está associada a um usuário
  Administrator Administrator? // 1-1 : (Opcional) Uma pessoa está associada a um administrador
}

model User {
  id Int @id @default(autoincrement())

  personId    Int  @unique // 1-1 : (Obrigatório) Um usuário está associado a uma pessoa
  loginUserId Int? @unique // 1-1 : (Opcional) Um usuário está associado a um login
  categoryId  Int? // 1-1 : (Opcional) Um usuário está associado a uma categoria
  typeGrantId Int? // 1-1 : (Opcional) Um usuário está associado a um tipo de bolsa

  person    Person     @relation(fields: [personId], references: [id])
  category  Category?  @relation(fields: [categoryId], references: [id])
  loginUser LoginUser? @relation(fields: [loginUserId], references: [id])
  typeGrant TypeGrant? @relation(fields: [typeGrantId], references: [id])

  picture  Picture? // 1-1 : (Opcional) Um usuário está associado a uma imagem
  student  Student? // 1-1 : (Opcional) Um usuário está associado a um estudante
  visitor  Visitor? // 1-1 : (Opcional) Um usuário está associado a um visitante
  employee Employee? // 1-1 : (Opcional) Um usuário está associado a um funcionário
}

model Student {
  id         Int    @id @default(autoincrement())
  enrollment String @unique

  userId   Int  @unique // 1-1 : (Obrigatório) Um funcionário está associado a um usuário
  courseId Int? // 1-N : (Obrigatório) Um estudante está associado a um curso que possui vários estudantes

  user   User    @relation(fields: [userId], references: [id])
  Course Course? @relation(fields: [courseId], references: [id])
}

model Visitor {
  id Int @id @default(autoincrement())

  userId Int  @unique // 1-1 : (Obrigatório) Um funcionário está associado a um usuário
  user   User @relation(fields: [userId], references: [id])
}

model Employee {
  id         Int    @id @default(autoincrement())
  enrollment String @unique

  userId Int  @unique // 1-1 : (Obrigatório) Um funcionário está associado a um usuário
  user   User @relation(fields: [userId], references: [id])
}

model Picture {
  id  Int    @id @default(autoincrement())
  url String @unique

  userId Int  @unique // 1-1 : (Obrigatório) Uma imagem está associada a um usuário
  user   User @relation(fields: [userId], references: [id])
}

// enum CategoryName {
//   ESTUDANTE   @map("ESTUDANTE")
//   FUNCIONARIO @map("FUNCIONARIO")
//   VISITANTE   @map("VISITANTE")
// }

model Category {
  id   Int    @id @default(autoincrement())
  name String @unique

  User User[] // N-1 : Uma categoria tem vários usuários
}

//
// enum TypeGrantName {
//   INTEGRAL
//   PARCIAL
//   NAO_APLICAVEL
// }

model TypeGrant {
  id   Int    @id @default(autoincrement())
  name String @unique

  User User[] // N-1 : Um tipo de bolsa tem vários usuários
}

model Course {
  id   Int    @id @default(autoincrement())
  name String @unique @default("")

  Student Student[]
}

model LoginUser {
  id               Int       @id @default(autoincrement())
  email            String    @unique
  password         String
  emailRecovery    String
  resetToken       String?
  resetTokenExpiry DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt

  user User? // 1-1: Um LoginUser está associado a um usuário
}
